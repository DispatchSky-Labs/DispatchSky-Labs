<!DOCTYPE html>
<html lang="en">
<head><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>CieloTracker Pro ‚Äì Flight Weather Monitor</title>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 20px;
      line-height: 1.4;
    }

    body.theme-light {
      background: #f5f5f5;
      color: #333;
    }

    .container {
      max-width: 1800px;
      margin: 0 auto;
    }

    h1 {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    button {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .theme-dark button {
      background: #2d2d2d;
      color: #e0e0e0;
    }

    .theme-light button {
      background: #fff;
      color: #333;
      border: 1px solid #ddd;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    button.active {
      background: #4CAF50;
      color: white;
    }

    .theme-toggle {
      background: #4CAF50 !important;
      color: white !important;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 30px;
      font-size: 13px;
    }

    .theme-dark table {
      background: #2d2d2d;
    }

    .theme-light table {
      background: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    th {
      padding: 12px 8px;
      text-align: left;
      font-weight: 600;
      border-bottom: 2px solid #4CAF50;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .theme-dark th {
      background: #1a1a1a;
    }

    .theme-light th {
      background: #f9f9f9;
    }

    td {
      padding: 10px 8px;
      vertical-align: top;
    }

    .theme-dark td {
      border-bottom: 1px solid #3d3d3d;
    }

    .theme-light td {
      border-bottom: 1px solid #eee;
    }

    tr:hover td {
      background: rgba(76, 175, 80, 0.1);
    }

    .icao-cell {
      font-weight: 600;
      font-size: 14px;
    }

    .weather-cell {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      max-width: 600px;
    }

    .hit {
      background: #d32f2f;
      color: white;
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: bold;
    }

    .theme-light .hit {
      background: #d32f2f;
      color: white;
    }

    .expired-metar {
      color: #ff9800;
      font-weight: bold;
    }

    .critical-expired {
      color: #f44336;
      font-weight: bold;
      text-decoration: underline;
    }

    .missing-elements {
      color: #9c27b0;
      font-style: italic;
    }

    .popup {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #323232;
      color: white;
      padding: 16px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      max-width: 400px;
      animation: slideIn 0.3s ease-out;
    }

    .theme-light .popup {
      background: white;
      color: #333;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      border: 1px solid #ddd;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .popup-header {
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 15px;
    }

    .popup-content {
      font-size: 13px;
      line-height: 1.5;
    }

    .popup-close {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      color: inherit;
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
    }

    .trigger-origin-red {
      background: #d32f2f;
      color: white;
      font-weight: bold;
    }

    .trigger-origin-bold {
      background: inherit;
      color: #ff6f00;
      font-weight: bold;
    }

    .trigger-dest-noalt {
      background: #d32f2f;
      color: white;
      font-weight: bold;
    }

    .trigger-dest, .trigger-dest-sent, .trigger-dest-out, .trigger-dest-term {
      background: inherit;
      color: #ff6f00;
      font-weight: bold;
    }

    .trigger-dest-out-metar {
      background: #b71c1c;
      color: white;
      font-weight: bold;
    }

    .trigger-alt-sent, .trigger-alt-out {
      background: inherit;
      color: #ff6f00;
      font-weight: bold;
    }

    .trigger-talt {
      background: inherit;
      color: #ff6f00;
      font-weight: bold;
    }

    .status {
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 6px;
      font-size: 13px;
    }

    .theme-dark .status {
      background: #2d2d2d;
    }

    .theme-light .status {
      background: white;
      border: 1px solid #ddd;
    }

    .loading {
      text-align: center;
      padding: 40px;
      font-size: 16px;
      color: #888;
    }

    .error {
      color: #f44336;
      padding: 20px;
      text-align: center;
      font-weight: 500;
    }

    @media (max-width: 768px) {
      body { padding: 10px; }
      h1 { font-size: 22px; }
      table { font-size: 11px; }
      th, td { padding: 6px 4px; }
      .weather-cell { font-size: 11px; }
      .popup { right: 10px; max-width: calc(100% - 20px); }
    }
  </style>
</head>
<body class="theme-light">
  <div class="container">
    <h1>
      <span>‚úàÔ∏è CieloTracker Pro</span>
      <span style="font-size: 14px; color: #888; font-weight: normal;">Flight Weather Monitor</span>
    </h1>

    <div class="controls">
      <button class="theme-toggle" onclick="toggleTheme()">üåì Toggle Theme</button>
      <button onclick="toggleFilter('all')" class="active" id="filter-all">All Flights</button>
      <button onclick="toggleFilter('planned')" id="filter-planned">Planned</button>
      <button onclick="toggleFilter('sent')" id="filter-sent">Sent</button>
      <button onclick="toggleFilter('out')" id="filter-out">Out</button>
      <button onclick="toggleFilter('in')" id="filter-in">In</button>
      <button onclick="toggleFilter('triggers')" id="filter-triggers">Triggers Only</button>
      <button onclick="manualRefresh()">üîÑ Refresh</button>
    </div>

    <div class="status" id="status">
      Loading flight data...
    </div>

    <div id="tables-container"></div>
  </div>

  <script>
(function() {
  'use strict';

  const BACKEND_URL = 'https://us-central1-weather-app-442103.cloudfunctions.net/process-weather-data-clean';
  const SHEET_ID = '1lOHbOZVRIoAjYiLEAOpYn6kEoA-lhxNRa98O5yvqb6c';
  const POLLING_INTERVAL = 60000;

  let flights = [];
  let weatherData = {};
  let currentFilter = 'all';
  let pollTimer = null;
  let lastTriggerState = new Map();
  let destinationImprovements = new Set();

  // NEW: Helper function to check for winds ‚â•40kt in raw METAR text
  function checkWindsInMetar(metarRaw) {
    if (!metarRaw) return false;
    const windRegex = /\b(VRB|\d{3})(\d{2,3})(G(\d{2,3}))?KT\b/g;
    let match;

    while ((match = windRegex.exec(metarRaw)) !== null) {
      const speed = parseInt(match[2], 10);
      const gust = match[4] ? parseInt(match[4], 10) : 0;

      if (speed >= 40 || gust >= 40) {
        return true;
      }
    }
    return false;
  }

  function containsHit(html) {
    return html && html.includes('class="hit"');
  }

  function getMetarHourHH(metarText) {
    if (!metarText) return null;
    const m = metarText.match(/\b\d{2}(\d{2})\d{2}Z\b/);
    return m ? m[1] : null;
  }

  function getTafBaseTextAtEtaHour(tafText, etaHHMM) {
    if (!tafText || !etaHHMM || etaHHMM.length !== 4) return '';
    const etaHH = parseInt(etaHHMM.slice(0, 2), 10);
    const lines = tafText.split(/\n/).filter(l => l.trim());
    let baseText = '';
    let currentHour = -1;

    for (const line of lines) {
      const fmMatch = line.match(/\bFM(\d{2})\d{4}\b/);
      if (fmMatch) {
        currentHour = parseInt(fmMatch[1], 10);
        if (currentHour === etaHH) baseText = line;
        else if (currentHour > etaHH) break;
      } else {
        const validMatch = line.match(/\b\d{4}\/\d{4}\b/);
        if (validMatch && currentHour === etaHH) baseText += ' ' + line;
      }
    }
    return baseText.trim();
  }

  function findTriggerTerms(text) {
    if (!text) return [];
    const terms = ['TSRA', 'TSGR', '+TSRA', 'FZRA', '+FZRA', 'FZDZ', 'PL', 'GR', 'GS', 'SN', '+SN', 'BLSN', 'SQ', 'FC', 'DS', 'SS', '+SS', 'VA'];
    return terms.filter(t => text.includes(t));
  }

  function findWorstWeather(metarText) {
    if (!metarText) return { ceiling: null, visibility: null };

    let worstCeiling = null;
    const ceilingRegex = /\b(BKN|OVC)(\d{3})\b/g;
    let match;
    while ((match = ceilingRegex.exec(metarText)) !== null) {
      const ceil = parseInt(match[2], 10);
      if (worstCeiling === null || ceil < worstCeiling) worstCeiling = ceil;
    }

    let worstVis = null;
    const visRegex = /\b(\d+(?:\/\d+)?)SM\b/g;
    while ((match = visRegex.exec(metarText)) !== null) {
      const visStr = match[1];
      let vis;
      if (visStr.includes('/')) {
        const parts = visStr.split('/');
        vis = parseFloat(parts[0]) / parseFloat(parts[1]);
      } else {
        vis = parseFloat(visStr);
      }
      if (worstVis === null || vis < worstVis) worstVis = vis;
    }

    return { ceiling: worstCeiling, visibility: worstVis };
  }

  function checkOriginTrigger(wx) {
    if (!wx || !wx.metar) return false;
    const html = wx.metar.html || '';
    const raw = wx.metar.raw || '';
    return containsHit(html) || findTriggerTerms(raw).length > 0;
  }

  function checkDestTrigger(wx, flight) {
    if (!wx) return false;
    const metarHtml = wx.metar ? wx.metar.html || '' : '';
    const metarRaw = wx.metar ? wx.metar.raw || '' : '';
    const tafHtml = wx.taf ? wx.taf.html || '' : '';
    const tafRaw = wx.taf ? wx.taf.raw || '' : '';

    const metarHit = containsHit(metarHtml) || findTriggerTerms(metarRaw).length > 0;

    let tafHit = false;
    if (flight.eta && flight.eta.length === 4) {
      const tafAtEta = getTafBaseTextAtEtaHour(tafRaw, flight.eta);
      const tafTerms = findTriggerTerms(tafAtEta);
      tafHit = tafTerms.length > 0 || (tafAtEta && containsHit(tafHtml));
    } else {
      tafHit = containsHit(tafHtml);
    }

    return metarHit || tafHit;
  }

  function checkAlternateTrigger(wx) {
    if (!wx || !wx.metar) return false;
    const html = wx.metar.html || '';
    const raw = wx.metar.raw || '';
    return containsHit(html) || findTriggerTerms(raw).length > 0;
  }

  function checkTakeoffAltTrigger(wx) {
    if (!wx || !wx.metar) return false;
    const html = wx.metar.html || '';
    const raw = wx.metar.raw || '';
    return containsHit(html) || findTriggerTerms(raw).length > 0;
  }

  function trackDestinationImprovement(flight, destWx, prevTrigger, currentTrigger) {
    if (flight.phase !== 'out') return;
    if (prevTrigger === true && currentTrigger === false) {
      destinationImprovements.add(flight.flightNumber);
    }
  }

  function checkWeatherTriggers() {
    flights.forEach(flight => {
      flight.triggers = flight.triggers || new Set();
      flight.triggers.clear();
      if (flight.phase === 'in') return;

      const originWx = weatherData[flight.origin];
      const destWx = weatherData[flight.dest];
      const taltWx = flight.takeoffAlt ? weatherData[flight.takeoffAlt] : null;
      const alt1Wx = flight.alt1 ? weatherData[flight.alt1] : null;
      const alt2Wx = flight.alt2 ? weatherData[flight.alt2] : null;

      if (checkOriginTrigger(originWx)) {
        if (flight.takeoffAlt) flight.triggers.add(`${flight.origin}:origin-bold`);
        else flight.triggers.add(`${flight.origin}:origin-red`);
      }

      // NEW: Client-side fallback for origin wind detection
      if (originWx && originWx.metar && originWx.metar.raw) {
        if (checkWindsInMetar(originWx.metar.raw)) {
          if (flight.takeoffAlt) {
            flight.triggers.add(`${flight.origin}:origin-bold`);
          } else {
            flight.triggers.add(`${flight.origin}:origin-red`);
          }
        }
      }

      const destTrigger = checkDestTrigger(destWx, flight);
      const prevDestTrigger = flight.prevDestTrigger !== undefined ? flight.prevDestTrigger : destTrigger;

      if (destTrigger) {
        if (flight.phase === 'planned' && !flight.alt1 && !flight.alt2) {
          flight.triggers.add(`${flight.dest}:dest-noalt`);
        } else if (flight.phase === 'planned') {
          flight.triggers.add(`${flight.dest}:dest`);
        } else if (flight.phase === 'sent') {
          flight.triggers.add(`${flight.dest}:dest-sent`);
        } else if (flight.phase === 'out') {
          flight.triggers.add(`${flight.dest}:dest-out`);
        }
      }

      // NEW: Client-side fallback for destination wind detection at ETA
      if (destWx && destWx.metar && destWx.metar.raw && flight.eta && flight.eta.length === 4) {
        const metarHH = getMetarHourHH(destWx.metar.raw);
        const etaHH = flight.eta.slice(0, 2);

        if (metarHH === etaHH && checkWindsInMetar(destWx.metar.raw)) {
          // NEW: Add wind indicator to destination
          flight.hasWindTrigger = true;

          if (flight.phase === 'planned') {
            if (!flight.alt1 && !flight.alt2) {
              flight.triggers.add(`${flight.dest}:dest-noalt`);
            } else {
              flight.triggers.add(`${flight.dest}:dest`);
            }
          } else if (flight.phase === 'sent') {
            flight.triggers.add(`${flight.dest}:dest-sent`);
          } else if (flight.phase === 'out') {
            flight.triggers.add(`${flight.dest}:dest-out`);
          }
        }
      }

      if (flight.phase === 'out' && destWx && destWx.metar) {
        const metarText = destWx.metar.raw || '';
        const worst = findWorstWeather(metarText);
        const metarTrigger = (worst.ceiling !== null && (worst.ceiling * 100) <= 200) || 
                            (worst.visibility !== null && worst.visibility <= 0.5);
        if (metarTrigger) {
          flight.triggers.add(`${flight.dest}:dest-out-metar`);
        }
      }

      const durationMin = parseInt(flight.duration, 10);
      const etaHHMM = flight.eta && flight.eta.length === 4 ? flight.eta : null;
      let destTermHit = false;

      if (destWx && etaHHMM) {
        if (destWx.taf && destWx.taf.raw) {
          const tafTextAtHour = getTafBaseTextAtEtaHour(destWx.taf.raw, etaHHMM);
          const tafTerms = findTriggerTerms(tafTextAtHour);
          if (tafTerms.length > 0) destTermHit = true;
        }
        if (!isNaN(durationMin) && durationMin < 60 && destWx.metar && destWx.metar.raw) {
          const metarHH = getMetarHourHH(destWx.metar.raw);
          if (metarHH && metarHH === etaHHMM.slice(0,2)) {
            const metarTerms = findTriggerTerms(destWx.metar.raw);
            if (metarTerms.length > 0) destTermHit = true;
          }
        }
      }

      if (destTermHit) {
        flight.triggers.add(`${flight.dest}:dest-term`);
      }

      trackDestinationImprovement(flight, destWx, prevDestTrigger, destTrigger);
      flight.prevDestTrigger = destTrigger;

      if (alt1Wx && checkAlternateTrigger(alt1Wx)) {
        if (flight.phase === 'sent') {
          flight.triggers.add(`${flight.alt1}:alt-sent`);
        } else if (flight.phase === 'out') {
          flight.triggers.add(`${flight.alt1}:alt-out`);
        }
      }
      if (alt2Wx && checkAlternateTrigger(alt2Wx)) {
        if (flight.phase === 'sent') {
          flight.triggers.add(`${flight.alt2}:alt-sent`);
        } else if (flight.phase === 'out') {
          flight.triggers.add(`${flight.alt2}:alt-out`);
        }
      }
      if (taltWx && checkTakeoffAltTrigger(taltWx)) flight.triggers.add(`${flight.takeoffAlt}:talt`);
    });
  }

  function checkForTriggerChanges() {
    const newTriggers = [];
    const clearedTriggers = [];

    flights.forEach(flight => {
      if (flight.phase === 'in') return;

      const currentTriggers = Array.from(flight.triggers || []);
      const flightKey = flight.flightNumber;
      const lastTriggers = lastTriggerState.get(flightKey) || [];

      currentTriggers.forEach(t => {
        if (!lastTriggers.includes(t)) {
          newTriggers.push({ flight: flightKey, trigger: t, dest: flight.dest });
        }
      });

      lastTriggers.forEach(t => {
        if (!currentTriggers.includes(t)) {
          clearedTriggers.push({ flight: flightKey, trigger: t, dest: flight.dest });
        }
      });

      lastTriggerState.set(flightKey, currentTriggers);
    });

    if (newTriggers.length > 0) {
      showPopup('New Triggers Detected', 
        newTriggers.map(t => `${t.flight}: ${t.trigger}`).join('<br>'),
        'trigger');
    }

    if (clearedTriggers.length > 0) {
      showPopup('Triggers Cleared', 
        clearedTriggers.map(t => `${t.flight}: ${t.trigger}`).join('<br>'),
        'cleared');
    }

    if (destinationImprovements.size > 0) {
      const improved = Array.from(destinationImprovements);
      showPopup('Weather Improved', 
        `Destinations improved for: ${improved.join(', ')}`,
        'improved');
      destinationImprovements.clear();
    }
  }

  function showPopup(title, message, type) {
    const existing = document.querySelectorAll('.popup');
    existing.forEach(p => p.remove());

    const popup = document.createElement('div');
    popup.className = 'popup';
    popup.innerHTML = `
      <button class="popup-close" onclick="this.parentElement.remove()">√ó</button>
      <div class="popup-header">${title}</div>
      <div class="popup-content">${message}</div>
    `;
    document.body.appendChild(popup);

    setTimeout(() => popup.remove(), 10000);
  }

  async function fetchFlightData() {
    try {
      const response = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/Sheet1?key=AIzaSyDSLqri6RKgLV9vE3sO98fXHB4V-Ol7Fj4`);
      if (!response.ok) throw new Error('Failed to fetch flight data');

      const data = await response.json();
      const rows = data.values || [];

      if (rows.length < 2) {
        updateStatus('No flight data available');
        return;
      }

      const headers = rows[0].map(h => h.toLowerCase().trim());
      flights = [];

      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const flight = {};

        headers.forEach((header, idx) => {
          flight[header] = row[idx] || '';
        });

        if (flight.flightnumber) {
          flight.flightNumber = flight.flightnumber;
          flight.phase = (flight.phase || '').toLowerCase();
          flight.triggers = new Set();
          flights.push(flight);
        }
      }

      updateStatus(`Loaded ${flights.length} flights`);
      await fetchWeatherData();
    } catch (error) {
      console.error('Error fetching flight data:', error);
      updateStatus(`Error: ${error.message}`, true);
    }
  }

  async function fetchWeatherData() {
    const icaos = new Set();
    flights.forEach(f => {
      if (f.origin) icaos.add(f.origin);
      if (f.dest) icaos.add(f.dest);
      if (f.alt1) icaos.add(f.alt1);
      if (f.alt2) icaos.add(f.alt2);
      if (f.takeoffAlt) icaos.add(f.takeoffAlt);
    });

    if (icaos.size === 0) {
      updateStatus('No ICAOs to fetch');
      renderTable();
      return;
    }

    try {
      const response = await fetch(BACKEND_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ icaos: Array.from(icaos) })
      });

      if (!response.ok) throw new Error('Backend request failed');

      const data = await response.json();
      weatherData = data.stations || {};

      checkWeatherTriggers();
      checkForTriggerChanges();
      renderTable();

      const now = new Date().toLocaleTimeString();
      updateStatus(`Last updated: ${now} | ${flights.length} flights | ${icaos.size} stations`);
    } catch (error) {
      console.error('Error fetching weather:', error);
      updateStatus(`Weather fetch error: ${error.message}`, true);
    }
  }

  function renderTable() {
    const container = document.getElementById('tables-container');
    container.innerHTML = '';

    const filteredFlights = flights.filter(f => {
      if (currentFilter === 'all') return true;
      if (currentFilter === 'triggers') return f.triggers && f.triggers.size > 0;
      return f.phase === currentFilter;
    });

    if (filteredFlights.length === 0) {
      container.innerHTML = '<div class="loading">No flights match the current filter</div>';
      return;
    }

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    thead.innerHTML = `
      <tr>
        <th>Flight #</th>
        <th>Origin</th>
        <th>Dest</th>
        <th>Alt1</th>
        <th>Alt2</th>
        <th>T/O Alt</th>
        <th>ETD</th>
        <th>ETA</th>
        <th>Duration</th>
        <th>Phase</th>
      </tr>
    `;
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    filteredFlights.forEach(flight => {
      const row = document.createElement('tr');

      const originClass = getTriggerClass(flight, flight.origin, 'origin');
      const destClass = getTriggerClass(flight, flight.dest, 'dest');
      const alt1Class = getTriggerClass(flight, flight.alt1, 'alt');
      const alt2Class = getTriggerClass(flight, flight.alt2, 'alt');
      const taltClass = getTriggerClass(flight, flight.takeoffAlt, 'talt');

      // NEW: Add wind emoji if destination has wind trigger
      const destDisplay = flight.hasWindTrigger ? `${flight.dest} üå¨Ô∏è` : flight.dest;

      row.innerHTML = `
        <td>${flight.flightNumber}</td>
        <td class="icao-cell ${originClass}" onclick="showWeatherPopup('${flight.origin}')">${flight.origin}</td>
        <td class="icao-cell ${destClass}" onclick="showWeatherPopup('${flight.dest}')">${destDisplay}</td>
        <td class="icao-cell ${alt1Class}" onclick="showWeatherPopup('${flight.alt1}')">${flight.alt1 || '-'}</td>
        <td class="icao-cell ${alt2Class}" onclick="showWeatherPopup('${flight.alt2}')">${flight.alt2 || '-'}</td>
        <td class="icao-cell ${taltClass}" onclick="showWeatherPopup('${flight.takeoffAlt}')">${flight.takeoffAlt || '-'}</td>
        <td>${flight.etd || '-'}</td>
        <td>${flight.eta || '-'}</td>
        <td>${flight.duration || '-'}</td>
        <td>${flight.phase}</td>
      `;
      tbody.appendChild(row);
    });

    table.appendChild(tbody);
    container.appendChild(table);
  }

  function getTriggerClass(flight, icao, type) {
    if (!flight.triggers || !icao) return '';

    const triggers = Array.from(flight.triggers);

    if (type === 'origin') {
      if (triggers.some(t => t === `${icao}:origin-red`)) return 'trigger-origin-red';
      if (triggers.some(t => t === `${icao}:origin-bold`)) return 'trigger-origin-bold';
    } else if (type === 'dest') {
      if (triggers.some(t => t === `${icao}:dest-noalt`)) return 'trigger-dest-noalt';
      if (triggers.some(t => t === `${icao}:dest-out-metar`)) return 'trigger-dest-out-metar';
      if (triggers.some(t => t.startsWith(`${icao}:dest`))) return 'trigger-dest';
    } else if (type === 'alt') {
      if (triggers.some(t => t.startsWith(`${icao}:alt`))) return 'trigger-alt-sent';
    } else if (type === 'talt') {
      if (triggers.some(t => t === `${icao}:talt`)) return 'trigger-talt';
    }

    return '';
  }

  function showWeatherPopup(icao) {
    if (!icao || icao === '-') return;

    const wx = weatherData[icao];
    if (!wx) {
      showPopup('Weather Data', `No data available for ${icao}`, 'info');
      return;
    }

    let content = `<strong>${icao}</strong><br><br>`;

    if (wx.metar) {
      content += `<strong>METAR:</strong><br>${wx.metar.raw || 'N/A'}<br><br>`;
    }

    if (wx.taf) {
      content += `<strong>TAF:</strong><br>${wx.taf.raw || 'N/A'}`;
    }

    showPopup('Weather Details', content, 'info');
  }

  function updateStatus(message, isError = false) {
    const status = document.getElementById('status');
    status.textContent = message;
    status.className = isError ? 'status error' : 'status';
  }

  window.toggleFilter = function(filter) {
    currentFilter = filter;

    document.querySelectorAll('.controls button').forEach(btn => {
      if (btn.id === `filter-${filter}`) {
        btn.classList.add('active');
      } else if (btn.id && btn.id.startsWith('filter-')) {
        btn.classList.remove('active');
      }
    });

    renderTable();
  };

  window.toggleTheme = function() {
    const body = document.body;
    if (body.classList.contains('theme-light')) {
      body.classList.remove('theme-light');
      body.classList.add('theme-dark');
      localStorage.setItem('theme', 'dark');
    } else {
      body.classList.remove('theme-dark');
      body.classList.add('theme-light');
      localStorage.setItem('theme', 'light');
    }
  };

  window.manualRefresh = function() {
    updateStatus('Refreshing...');
    fetchFlightData();
  };

  function startPolling() {
    if (pollTimer) clearInterval(pollTimer);
    pollTimer = setInterval(fetchFlightData, POLLING_INTERVAL);
  }

  function init() {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
      document.body.classList.remove('theme-light');
      document.body.classList.add('theme-dark');
    }

    fetchFlightData();
    startPolling();
  }

  init();
})();
  </script>
</body>
</html>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>CieloTracker Pro ‚Äì Flight Weather Monitor</title>

  <style>
    /* ... [All existing styles remain unchanged] ... */
  </style>
</head>
<body class="theme-light">

  <!-- ... [All existing HTML structure remains unchanged] ... -->

  <script>
(function() {
  'use strict';

  // ... [All existing constants and variables remain unchanged] ...

  // NEW: Helper function to check for winds ‚â•40kt in raw METAR text
  function checkWindsInMetar(metarRaw) {
    if (!metarRaw) return false;
    // Regex matches: VRB or 3-digit direction, speed (2-3 digits), optional gust, KT
    const windRegex = /\b(VRB|\d{3})(\d{2,3})(G(\d{2,3}))?KT\b/g;
    let match;

    while ((match = windRegex.exec(metarRaw)) !== null) {
      const speed = parseInt(match[2], 10);
      const gust = match[4] ? parseInt(match[4], 10) : 0;

      // Return true if wind or gust meets threshold
      if (speed >= 40 || gust >= 40) {
        return true;
      }
    }
    return false;
  }

  // ... [All existing utility functions remain unchanged] ...

  // Modified function: checkWeatherTriggers
  function checkWeatherTriggers() {
    flights.forEach(flight => {
      flight.triggers.clear();
      if (flight.phase === 'in') return;

      const originWx = weatherData[flight.origin];
      const destWx = weatherData[flight.dest];
      const taltWx = flight.takeoffAlt ? weatherData[flight.takeoffAlt] : null;
      const alt1Wx = flight.alt1 ? weatherData[flight.alt1] : null;
      const alt2Wx = flight.alt2 ? weatherData[flight.alt2] : null;

      // Check origin for all phases, not just 'planned'
      if (checkOriginTrigger(originWx)) {
        if (flight.takeoffAlt) flight.triggers.add(`${flight.origin}:origin-bold`);
        else flight.triggers.add(`${flight.origin}:origin-red`);
      }

      // NEW: Client-side fallback for origin wind detection
      // Check if backend didn't catch it (defensive fallback)
      if (originWx && originWx.metar && originWx.metar.raw) {
        if (checkWindsInMetar(originWx.metar.raw)) {
          if (flight.takeoffAlt) {
            if (!flight.triggers.has(`${flight.origin}:origin-bold`)) {
              flight.triggers.add(`${flight.origin}:origin-bold`);
            }
          } else {
            if (!flight.triggers.has(`${flight.origin}:origin-red`)) {
              flight.triggers.add(`${flight.origin}:origin-red`);
            }
          }
        }
      }

      const destTrigger = checkDestTrigger(destWx, flight);
      const prevDestTrigger = flight.prevDestTrigger !== undefined ? flight.prevDestTrigger : destTrigger;

      if (destTrigger) {
        if (flight.phase === 'planned' && !flight.alt1 && !flight.alt2) {
          flight.triggers.add(`${flight.dest}:dest-noalt`);
        } else if (flight.phase === 'planned') {
          flight.triggers.add(`${flight.dest}:dest`);
        } else if (flight.phase === 'sent') {
          flight.triggers.add(`${flight.dest}:dest-sent`);
        } else if (flight.phase === 'out') {
          flight.triggers.add(`${flight.dest}:dest-out`);
        }
      }

      // NEW: Client-side fallback for destination wind detection at ETA
      // Only check METAR at exact ETA hour (whole hours only, no rounding)
      if (destWx && destWx.metar && destWx.metar.raw && flight.eta && flight.eta.length === 4) {
        const metarHH = getMetarHourHH(destWx.metar.raw);
        const etaHH = flight.eta.slice(0, 2); // Extract hour from ETA (e.g., "23" from "2345")

        // Check if METAR hour matches ETA hour exactly
        if (metarHH === etaHH) {
          if (checkWindsInMetar(destWx.metar.raw)) {
            // Add trigger based on phase and alternates
            if (flight.phase === 'planned') {
              if (!flight.alt1 && !flight.alt2) {
                if (!flight.triggers.has(`${flight.dest}:dest-noalt`)) {
                  flight.triggers.add(`${flight.dest}:dest-noalt`);
                }
              } else {
                if (!flight.triggers.has(`${flight.dest}:dest`)) {
                  flight.triggers.add(`${flight.dest}:dest`);
                }
              }
            } else if (flight.phase === 'sent') {
              if (!flight.triggers.has(`${flight.dest}:dest-sent`)) {
                flight.triggers.add(`${flight.dest}:dest-sent`);
              }
            } else if (flight.phase === 'out') {
              if (!flight.triggers.has(`${flight.dest}:dest-out`)) {
                flight.triggers.add(`${flight.dest}:dest-out`);
              }
            }
          }
        }
      }

      if (flight.phase === 'out' && destWx && destWx.metar) {
        const metarText = destWx.metar.raw || '';
        const worst = findWorstWeather(metarText);
        const metarTrigger = (worst.ceiling !== null && (worst.ceiling * 100) <= 200) || 
                            (worst.visibility !== null && worst.visibility <= 0.5);
        if (metarTrigger) {
          flight.triggers.add(`${flight.dest}:dest-out-metar`);
        }
      }

      // Destination trigger-term detection at ETA hour
      const durationMin = parseInt(flight.duration, 10);
      const etaHHMM = flight.eta && flight.eta.length === 4 ? flight.eta : null;
      let destTermHit = false;

      if (destWx && etaHHMM) {
        // TAF at ETA hour (always)
        if (destWx.taf && destWx.taf.raw) {
          const tafTextAtHour = getTafBaseTextAtEtaHour(destWx.taf.raw, etaHHMM);
          const tafTerms = findTriggerTerms(tafTextAtHour);
          if (tafTerms.length > 0) destTermHit = true;
        }
        // METAR at ETA hour only if duration < 60
        if (!isNaN(durationMin) && durationMin < 60 && destWx.metar && destWx.metar.raw) {
          const metarHH = getMetarHourHH(destWx.metar.raw);
          if (metarHH && metarHH === etaHHMM.slice(0,2)) {
            const metarTerms = findTriggerTerms(destWx.metar.raw);
            if (metarTerms.length > 0) destTermHit = true;
          }
        }
      }

      if (destTermHit) {
        flight.triggers.add(`${flight.dest}:dest-term`);
      }

      trackDestinationImprovement(flight, destWx, prevDestTrigger, destTrigger);
      flight.prevDestTrigger = destTrigger;

      if (alt1Wx && checkAlternateTrigger(alt1Wx, flight)) {
        if (flight.phase === 'sent') {
          flight.triggers.add(`${flight.alt1}:alt-sent`);
        } else if (flight.phase === 'out') {
          flight.triggers.add(`${flight.alt1}:alt-out`);
        }
      }
      if (alt2Wx && checkAlternateTrigger(alt2Wx, flight)) {
        if (flight.phase === 'sent') {
          flight.triggers.add(`${flight.alt2}:alt-sent`);
        } else if (flight.phase === 'out') {
          flight.triggers.add(`${flight.alt2}:alt-out`);
        }
      }
      if (taltWx && checkTakeoffAltTrigger(taltWx)) flight.triggers.add(`${flight.takeoffAlt}:talt`);
    });
  }

  // ... [All remaining functions remain unchanged] ...

})();
  </script>
</body>
</html>

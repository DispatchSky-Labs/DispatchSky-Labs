<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>CieloTracker Pro – Flight Weather Monitor</title>

  <style>
    /* ... [All existing styles remain unchanged] ... */
  </style>
</head>
<body class="theme-light">

  <!-- ... [All existing HTML structure remains unchanged] ... -->

  <script>
(function() {
  'use strict';

  // ... [All existing constants and variables remain unchanged] ...

  // NEW: Helper function to check for winds ≥40kt in raw METAR text
  function checkWindsInMetar(metarRaw) {
    if (!metarRaw) return false;
    // Regex matches: VRB or 3-digit direction, speed (2-3 digits), optional gust, KT
    const windRegex = /\b(VRB|\d{3})(\d{2,3})(G(\d{2,3}))?KT\b/g;
    let match;

    while ((match = windRegex.exec(metarRaw)) !== null) {
      const speed = parseInt(match[2], 10);
      const gust = match[4] ? parseInt(match[4], 10) : 0;

      // Return true if wind or gust meets threshold
      if (speed >= 40 || gust >= 40) {
        return true;
      }
    }
    return false;
  }

  // ... [All existing utility functions remain unchanged] ...

  // Modified function: checkWeatherTriggers
  function checkWeatherTriggers() {
    flights.forEach(flight => {
      flight.triggers.clear();
      if (flight.phase === 'in') return;

      const originWx = weatherData[flight.origin];
      const destWx = weatherData[flight.dest];
      const taltWx = flight.takeoffAlt ? weatherData[flight.takeoffAlt] : null;
      const alt1Wx = flight.alt1 ? weatherData[flight.alt1] : null;
      const alt2Wx = flight.alt2 ? weatherData[flight.alt2] : null;

      // Check origin for all phases, not just 'planned'
      if (checkOriginTrigger(originWx)) {
        if (flight.takeoffAlt) flight.triggers.add(`${flight.origin}:origin-bold`);
        else flight.triggers.add(`${flight.origin}:origin-red`);
      }

      // NEW: Client-side fallback for origin wind detection
      // Check if backend didn't catch it (defensive fallback)
      if (originWx && originWx.metar && originWx.metar.raw) {
        if (checkWindsInMetar(originWx.metar.raw)) {
          if (flight.takeoffAlt) {
            if (!flight.triggers.has(`${flight.origin}:origin-bold`)) {
              flight.triggers.add(`${flight.origin}:origin-bold`);
            }
          } else {
            if (!flight.triggers.has(`${flight.origin}:origin-red`)) {
              flight.triggers.add(`${flight.origin}:origin-red`);
            }
          }
        }
      }

      const destTrigger = checkDestTrigger(destWx, flight);
      const prevDestTrigger = flight.prevDestTrigger !== undefined ? flight.prevDestTrigger : destTrigger;

      if (destTrigger) {
        if (flight.phase === 'planned' && !flight.alt1 && !flight.alt2) {
          flight.triggers.add(`${flight.dest}:dest-noalt`);
        } else if (flight.phase === 'planned') {
          flight.triggers.add(`${flight.dest}:dest`);
        } else if (flight.phase === 'sent') {
          flight.triggers.add(`${flight.dest}:dest-sent`);
        } else if (flight.phase === 'out') {
          flight.triggers.add(`${flight.dest}:dest-out`);
        }
      }

      // NEW: Client-side fallback for destination wind detection at ETA
      // Only check METAR at exact ETA hour (whole hours only, no rounding)
      if (destWx && destWx.metar && destWx.metar.raw && flight.eta && flight.eta.length === 4) {
        const metarHH = getMetarHourHH(destWx.metar.raw);
        const etaHH = flight.eta.slice(0, 2); // Extract hour from ETA (e.g., "23" from "2345")

        // Check if METAR hour matches ETA hour exactly
        if (metarHH === etaHH) {
          if (checkWindsInMetar(destWx.metar.raw)) {
            // Add trigger based on phase and alternates
            if (flight.phase === 'planned') {
              if (!flight.alt1 && !flight.alt2) {
                if (!flight.triggers.has(`${flight.dest}:dest-noalt`)) {
                  flight.triggers.add(`${flight.dest}:dest-noalt`);
                }
              } else {
                if (!flight.triggers.has(`${flight.dest}:dest`)) {
                  flight.triggers.add(`${flight.dest}:dest`);
                }
              }
            } else if (flight.phase === 'sent') {
              if (!flight.triggers.has(`${flight.dest}:dest-sent`)) {
                flight.triggers.add(`${flight.dest}:dest-sent`);
              }
            } else if (flight.phase === 'out') {
              if (!flight.triggers.has(`${flight.dest}:dest-out`)) {
                flight.triggers.add(`${flight.dest}:dest-out`);
              }
            }
          }
        }
      }

      if (flight.phase === 'out' && destWx && destWx.metar) {
        const metarText = destWx.metar.raw || '';
        const worst = findWorstWeather(metarText);
        const metarTrigger = (worst.ceiling !== null && (worst.ceiling * 100) <= 200) || 
                            (worst.visibility !== null && worst.visibility <= 0.5);
        if (metarTrigger) {
          flight.triggers.add(`${flight.dest}:dest-out-metar`);
        }
      }

      // Destination trigger-term detection at ETA hour
      const durationMin = parseInt(flight.duration, 10);
      const etaHHMM = flight.eta && flight.eta.length === 4 ? flight.eta : null;
      let destTermHit = false;

      if (destWx && etaHHMM) {
        // TAF at ETA hour (always)
        if (destWx.taf && destWx.taf.raw) {
          const tafTextAtHour = getTafBaseTextAtEtaHour(destWx.taf.raw, etaHHMM);
          const tafTerms = findTriggerTerms(tafTextAtHour);
          if (tafTerms.length > 0) destTermHit = true;
        }
        // METAR at ETA hour only if duration < 60
        if (!isNaN(durationMin) && durationMin < 60 && destWx.metar && destWx.metar.raw) {
          const metarHH = getMetarHourHH(destWx.metar.raw);
          if (metarHH && metarHH === etaHHMM.slice(0,2)) {
            const metarTerms = findTriggerTerms(destWx.metar.raw);
            if (metarTerms.length > 0) destTermHit = true;
          }
        }
      }

      if (destTermHit) {
        flight.triggers.add(`${flight.dest}:dest-term`);
      }

      trackDestinationImprovement(flight, destWx, prevDestTrigger, destTrigger);
      flight.prevDestTrigger = destTrigger;

      if (alt1Wx && checkAlternateTrigger(alt1Wx, flight)) {
        if (flight.phase === 'sent') {
          flight.triggers.add(`${flight.alt1}:alt-sent`);
        } else if (flight.phase === 'out') {
          flight.triggers.add(`${flight.alt1}:alt-out`);
        }
      }
      if (alt2Wx && checkAlternateTrigger(alt2Wx, flight)) {
        if (flight.phase === 'sent') {
          flight.triggers.add(`${flight.alt2}:alt-sent`);
        } else if (flight.phase === 'out') {
          flight.triggers.add(`${flight.alt2}:alt-out`);
        }
      }
      if (taltWx && checkTakeoffAltTrigger(taltWx)) flight.triggers.add(`${flight.takeoffAlt}:talt`);
    });
  }

  // ... [All remaining functions remain unchanged] ...

})();
  </script>
</body>
</html>
